### 创建型操作符
* create：从头到尾创建一个Observable
* defer：为每一个订阅者创建一个Observable
* empty：创建一个不发射任何数据但是正常终止的Observable
* never：创建一个不发射任何数据也不终止的Observable
* throw：创建一个不发射数据直接错误的Observable
* from：将其他数据类型转换为Observable，可以是数组和列表类型
* interval：每隔一定时间发送一个整型数据，从0开始，不主动结束。本身运行在Schedulers.computation中
* just：将对象或集合转换为一个发射这些对象的Observable
* range，创建发射指定范围的正数序列的Observable
* repeat：将原始Observable重复发射
* timer：每隔一定时间发送一个0。

### 转换型操作符
* map：将一个Observable转换为另一个Observable
* flatMap：将一个Observable转换为Observable集合
* buffer：定期从Observable手机一个集合，然后打包发射
* window：窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集
* scan：扫描，连续地对数据序列的每一项应用一个函数，然后连续发射结果,每一项结果基于之前的结果.累加器函数，通过查看官方示意图很好理解
* toList：将Observable发射的所有数据放在一个List中一次性发射
* groupBy：分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据；

### 过滤操作符
* debounce：操作符对源Observable每产生一个结果后，如果在规定的间隔时间内没有别的结果产生，则把这个结果提交给订阅者处理，否则忽略该结果。
* distinct：过滤重复数据
* elementAt：只发射第n项数据
* filter：过滤
* first：只发射满足条件的第一个数据或数据源中的第一条数据
* ignoreElements：不发射任何数据知道error或completed
* last：只发射满足条件的最后一条数据
* sample：取样，在指定的时间间隔内取最近发射的那个数据
* skip：跳过前面若干项
* skipLast：跳过后面若干项
* take：只保留前面若干项
* takeLast：只保留后面若干项
* takeFirst：只取第一项，和first类型，只是first没有数据会执行error，而takeFirst执行completed

### 组合操作符
* merge：合并Observables到一个Observable并发射
* zip：合并多个Observable并通过Fun来变换然后发射
* startWith：在调用者发射之前发射
* concat：按顺序发送数据
* join：..

### 错误操作符
* onErrorReturn：当发生错误时，让Observable发射一个预定好的数据并正常终止，不会抛出异常
* onErrorResumeNext：当发生错误，由另一个Observable代替当前的Observable并继续发送数据
* onExceptionResumeNext：与onErrorResumeNext类似，但onErrorResumeNext可以处理所有错误，onExceptionResumeNext只能处理异常
* retry：当发生错误时会重试n次，第n次不成功则调用error

### 辅助操作符
* delay：延迟一段时间
* doOnEach：注册一个动作，对每个发射的数据都使用
* doOnNext：
* doOnSubscribe：
* doOnUnsubscribe：
* doOnCompleted：
* doOnError：以上都是注册一个动作
* doOnTerminate：Observable终止之前调用，无论是error还是completed
* finallyDo：Observable终止之后调用，无论是error还是completed
* materialize：将Observable转换成一个通知列表
* dematerialize：将通知转换回一个Observable
* timestamp：给Observable发射的每个数据都加上时间戳
* timeInterval：给Observable发射的两个数据项之间添加一个时间差
* timeout：对原始Observable的一个镜像，如果过了一个指定的时长仍没有发射数据，它会发一个错误通知
* observeOn：指定观察者观察Observable的调度器
* subscribeOn：指定Observable执行任务的调度器
* using：..
* serialize：强制Observable按次序发射数据并且要求功能是完好的

### 条件和布尔操作符
* all：判断Observable所发射的数据是否都满足一个条件
* contains：判断源Observable所发射的数据是否包含某一个数据
* isEmpty：判断Observable是否发射过数据
* sequenceEqual：两个Observable数据序列是否相同，发射数据相同、数据的序列相同、结束的状态相同，相同返回true
* amb：竞争操作符。最多可以连接9个observable，哪个最先发射数据就只会发射它的数据，其它的舍弃
* defaultIfEmpty：如果原始的observable没有发射出一个数据则发送一个默认的数据。否则正常发射数据
* skipUntil：跳过标志Observable之前的数据
* skipWhile：判断是否跳过该数据
* takeUntil：跳过编制Observable之后的数据
* takeWhile：判断是否使用该数据

### 数字运算于聚合操作符
* averageInteger：求数据序列平均数并发射，数据序列为整型
* averageLong：求数据序列平均数并发射，数据序列为long型
* averageFloat：求数据序列平均数并发射，数据序列为float型
* averageDouble：求数据序列平均数并发射，数据序列为double型
* max：求最大值并发射
* maxBy：求最大Key对应的值并发射
* min：求最小值并发射
* minBy：求最小Key对应的值并发射
* sumInteger：求和并发射
* sumLong：求和并发射
* sumFloat：求和并发射
* sumDouble：求和并发射
* count：统计发射了多少数据
* countLong：统计发射了多少数据
* reduce：Reduce操作符应用一个函数接收Observable发射的数据和函数的计算结果作为下次计算的参数，输出最后的结果。跟前面我们了解过的scan操作符很类似，只是scan会输出每次计算的结果，而reduce只会输出最后的结果
* collect：用来将源Observable发射的数据给收集到一个数据结构里面，需要使用两个参数：1.一个产生收集数据结构的函数；2.一个接收第一个函数产生的数据结构和源Observable发射的数据作为参数的函数
* toList：收集原始Observable发射的所有数据到一个列表，然后返回这个列表

### 连接操作符
* public：将一个Observable转换为一个可连接的Observable
* connect：指示一个可连接的Observable开始发射数据
* replay：..
* replayCount：..